
_G["X"]="      ▄     ▄███▄      ▄   ▄█▄  "
_G["_"]=" ▀▄   █    █▀   ▀      █  █▀ ▀▄ "
_G["E"]="   █ ▀  -  ██▄▄    ██   █ █   ▀ "
_G["N"]="  ▄ █      █▄   ▄▀ █ █  █ █▄  ▄▀"
_G["C"]=" █   ▀▄    ▀███▀   █  █ █ ▀███▀ "
_G["W"]="  ▀                █   ██ dsc.gg/obfuscation"
--[[ (Anti Sandbox On) Run only in a Roblox exec, or it will not work ]]
G=_G G["_dsc.gg/obfuscation"]=" 　⁢ ⁤ ⁢  ⁢         ⁢ ㅤ⁤   　 ⁤  ᠎ ⁤       　‌⁤⁢ ᠎ ⁢᠎᠎   　    ‌   　    　    ㅤ ⁢   ㅤ ‌ ᠎ ⁢    ㅤ      ‌ ᠎‌⁢  ⁢᠎⁤   ‌    ㅤ ᠎᠎⁢　 ᠎‌ ᠎ㅤ  ⁢‌ ㅤ ⁢　᠎　⁤‌　⁤ㅤ     ⁤　⁤     ⁤       　  ‌᠎ 　  ᠎ ‌⁤⁢᠎ ㅤ‌ ‌ 　‌ㅤ   ⁤‌            ㅤ ⁤ㅤ　　 ⁢  ‌       ㅤㅤ  ‌ ⁢ ⁢‌    ‌⁢ㅤ⁢   ⁢     ᠎ㅤ   　 　  ᠎   ᠎ ㅤ᠎  　　⁢ 　　⁢  　᠎᠎᠎⁤ 　  ‌ ㅤ      　　 ‌᠎⁢᠎ ⁤   ‌⁢     ㅤ     ⁢‌ ⁢ ‌  ㅤ　         ⁢ ㅤ⁢    ⁤    ㅤ    ⁢‌    ⁤ 　       ⁢᠎ ‌ ⁤  ⁤  ⁢  ‌‌     ⁤ ᠎　          ⁢ ‌ ㅤ⁢ ㅤ ⁢      ㅤ‌   ㅤ    ⁤ㅤ ㅤ    ㅤ ㅤ 　ㅤ 　　 ‌ㅤ  ⁢      ㅤ ⁤⁤　 ㅤ ㅤ   　  ⁤  ⁤  　ㅤ⁤ ᠎‌  ᠎ ㅤ   　　᠎  ㅤ ‌    ⁢   ‌   ‌  ‌      ⁢    　   ‌　‌  ‌   ⁢‌ 　⁢  ‌  ‌ㅤㅤ   ㅤ    ⁤  　‌　ㅤ‌ 　 ⁢᠎　 ⁢⁢‌   ‌ㅤ      ⁢ ⁤  ⁤  ‌   ‌   ⁢ 　ㅤ  ⁤       ⁢᠎    ⁢   ⁤⁤　᠎  ᠎ ⁤ 　 ᠎ ⁢⁤   ᠎　⁤　   ⁤  ‌᠎⁤ 　ㅤ᠎ ‌　       ⁤   ⁤⁢⁤   　   ᠎‌ ㅤ⁢  ‌  ‌  ‌ 　 　‌ ᠎      　      ⁤  ⁤⁤          ⁤  ⁢   ⁢   ⁢ ᠎    　  ⁢ㅤ　᠎  ㅤ       ‌   ‌᠎ㅤ ‌   ‌  ᠎‌　 ⁤ ‌ ᠎᠎  ⁢     　 ⁢ ‌     ⁤   ᠎ㅤ ⁤⁤ ⁤⁤‌⁤    ⁤⁤    ⁢ ⁤       ⁤ ᠎     ⁤  ⁤ㅤ           ⁤   ㅤ  ⁢    ⁤ ⁢  ㅤ  ᠎ㅤ‌⁢    ‌ ‌   ⁤     ㅤ᠎       ⁢᠎　⁤ ⁢  ᠎   ㅤ ᠎   ᠎ ‌ ⁤ ㅤ  ‌ ᠎   ⁢ ⁢  ⁤    ⁢  ‌ ⁢  ⁤‌   　  ᠎ 　⁤ ⁤ ‌  ㅤ    ᠎　‌    ⁤  ᠎     ㅤㅤ᠎ ㅤ ㅤ  ㅤ 　  ⁤  　    ‌   　    ‌  ‌ ㅤ  ㅤ    ㅤㅤ 　      ᠎⁢     ⁢᠎⁢  ⁢    ⁢ ‌᠎ 　‌  ⁢       ⁢      ‌  ⁤‌    ⁤᠎‌      ᠎  ⁢⁢      ㅤ　 ⁢ ᠎ ᠎   ⁤ ‌᠎᠎ 　⁤⁤᠎ ㅤ᠎       ‌ ‌ ⁤  ⁤  ‌  ᠎⁤ ‌ ‌ 　‌⁤ㅤ ⁢         　  ⁢‌ ᠎     ⁢ ᠎ㅤ᠎‌⁢⁢   ‌⁤‌  ⁢ ᠎   ㅤ  ⁤ 　     　     　‌  ㅤㅤ ‌ "-- CHECKHERE-- === START ANTI SANDBOX ===local toplevelinfo = 0while debug.info(toplevelinfo, "f") do    toplevelinfo = toplevelinfo + 1endtoplevelinfo = toplevelinfo - 1if toplevelinfo > 5 then    error("stop skidding bro")end-- === END ANTI SANDBOX ===local bit32 = bit32 or {}if not bit32.bxor then    function bit32.bxor(a, b)        local result = 0        local bit = 1        for i = 0, 31 do            if (a % 2) ~= (b % 2) then result = result + bit end            a = math.floor(a / 2)            b = math.floor(b / 2)            bit = bit * 2        end        return result    endendif not bit32.band then    function bit32.band(a, b)        local result = 0        local bit = 1        for i = 0, 31 do            if (a % 2 == 1) and (b % 2 == 1) then result = result + bit end            a = math.floor(a / 2)            b = math.floor(b / 2)            bit = bit * 2        end        return result    endendif not bit32.lshift then    function bit32.lshift(a, disp)        return (a * (2 ^ disp)) % (2 ^ 32)    endendif not bit32.rshift then    function bit32.rshift(a, disp)        return math.floor(a / (2 ^ disp))    endend-- Unicode character maplocal unicode_chars = {"⁢"," ","　","‌"," ","ㅤ"," "," ","⁤"," "," "," "," "," "," ","᠎"}-- Build reverse lookup tablelocal unicode_reverse = {}for i, char in ipairs(unicode_chars) do    unicode_reverse[char] = i - 1end-- Decode Unicode string to byteslocal function decode_unicode(str)    local bytes = {}    local char_count = 0    local utf8_pos = 1        while utf8_pos <= #str do        local byte_val = string.byte(str, utf8_pos)        local char_len = 1                if byte_val >= 240 then char_len = 4        elseif byte_val >= 224 then char_len = 3        elseif byte_val >= 192 then char_len = 2        end                local char = string.sub(str, utf8_pos, utf8_pos + char_len - 1)        utf8_pos = utf8_pos + char_len                local idx = unicode_reverse[char]        if idx then            char_count = char_count + 1            local byte_pos = math.ceil(char_count / 2)                        if char_count % 2 == 1 then                bytes[byte_pos] = idx * 16            else                bytes[byte_pos] = (bytes[byte_pos] or 0) + idx            end        end    end        local result = {}    for j = 1, #bytes do        result[j] = string.char(bytes[j])    end    return table.concat(result)endlocal function xor_multi_decode(data)    local result = {}    for i = 1, #data do        result[i] = string.char(bit32.bxor(string.byte(data, i), ((i - 1) * 3 + 7) % 256))    end    return table.concat(result)endlocal function rot_complex_decode(data)    local result = {}    for i = 1, #data do        local b = string.byte(data, i)        result[i] = string.char((b - (13 + (i - 1) % 17) + 256) % 256)    end    return table.concat(result)endlocal function swap_adv_decode(data)    local bytes = {}    for i = 1, #data do bytes[i] = string.byte(data, i) end        for i = 1, #bytes - 3, 4 do        bytes[i], bytes[i + 3] = bytes[i + 3], bytes[i]        bytes[i + 1], bytes[i + 2] = bytes[i + 2], bytes[i + 1]    end        local result = {}    for i = 1, #bytes do result[i] = string.char(bytes[i]) end    return table.concat(result)endlocal function reverse_decode(data)    local result = {}    for i = #data, 1, -1 do        result[#result + 1] = string.char(string.byte(data, i))    end    return table.concat(result)endlocal function add_multi_decode(data)    local result = {}    for i = 1, #data do        local b = string.byte(data, i)        result[i] = string.char((b - ((i - 1) * 11 + 23) % 256 + 256) % 256)    end    return table.concat(result)endlocal function shuffle_block_decode(data)    local bytes = {}    for i = 1, #data do bytes[i] = string.byte(data, i) end        local block_size = 8    for block_start = 1, #bytes, block_size do        local block = {}        for i = 0, block_size - 1 do            if bytes[block_start + i] then                block[i + 1] = bytes[block_start + i]            end        end                -- Generate all swap indices (same as shuffle)        local swaps = {}        local seed = block_start - 1        for i = #block, 2, -1 do            seed = bit32.band((seed * 1103515245 + 12345), 0x7fffffff)            local j = (seed % i) + 1            swaps[#swaps + 1] = {i, j}        end                -- Apply swaps in REVERSE order to undo shuffle        for k = #swaps, 1, -1 do            local i, j = swaps[k][1], swaps[k][2]            block[i], block[j] = block[j], block[i]        end                for i = 1, #block do            bytes[block_start + i - 1] = block[i]        end    end        local result = {}    for i = 1, #bytes do result[i] = string.char(bytes[i]) end    return table.concat(result)endlocal function xor_cascade_decode(data)    local bytes = {}    for i = 1, #data do bytes[i] = string.byte(data, i) end        for i = #bytes, 2, -1 do        bytes[i] = bit32.bxor(bytes[i], bytes[i - 1])    end        local result = {}    for i = 1, #bytes do result[i] = string.char(bytes[i]) end    return table.concat(result)endlocal function bit_rotate_decode(data)    local result = {}    for i = 1, #data do        local b = string.byte(data, i)        result[i] = string.char(bit32.band(bit32.rshift(b, 3) + bit32.lshift(b, 5), 0xFF))    end    return table.concat(result)endlocal function decode(data)    local decoded = decode_unicode(data)    local layers = {xor_cascade_decode, add_multi_decode, xor_multi_decode, reverse_decode, rot_complex_decode, swap_adv_decode, bit_rotate_decode, shuffle_block_decode}    local result = decoded    for i = 1, #layers do        result = layers[i](result)    end    return resultendif _G["X"] ~= "      ▄     ▄███▄      ▄   ▄█▄  " then    error("WHY TF ARE U REMOVING THE VANITY???")endif _G["_"] ~= " ▀▄   █    █▀   ▀      █  █▀ ▀▄ " then    error("WHY TF ARE U REMOVING THE VANITY???")endif _G["E"] ~= "   █ ▀  -  ██▄▄    ██   █ █   ▀ " then    error("WHY TF ARE U REMOVING THE VANITY???")endif _G["N"] ~= "  ▄ █      █▄   ▄▀ █ █  █ █▄  ▄▀" then    error("WHY TF ARE U REMOVING THE VANITY???")endif _G["C"] ~= " █   ▀▄    ▀███▀   █  █ █ ▀███▀ " then    error("WHY TF ARE U REMOVING THE VANITY???")endif _G["W"] ~= "  ▀                █   ██ dsc.gg/obfuscation" then    error("WHY TF ARE U REMOVING THE VANITY???")end-- Initialize and executelocal function _0xexec()    local _0xdec = decode(_G["_dsc.gg/obfuscation"])    local _0xfunc, _0xerr = loadstring(_0xdec)        if _0xfunc then        return _0xfunc()    else        error("Integrity check failed: " .. tostring(_0xerr))    endendreturn _0xexec()
            